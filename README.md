Задачи из Яндекс.Контест для Яндекс Стажировки

1. Фоторамки

Статус: Частичное решение, 17/20 баллов

Есть участок стены, на которую решили повесить фоторамки. У данного участка известна ширина и высота.

Нужно написать функцию раскладки фоторамок на этом участке стены в зависимости от количества фоторамок.
Пример правильного расположения фоторамок:
![alt text](https://i.postimg.cc/GpxSLqL4/1.png)
Раскладка должна быть симметричной относительно вертикали, все фоторамки должны быть одинакового размера и иметь такие же соотношения высоты и ширины, как и кусок стены. Если фоторамок не хватает для заполнения строки, то такая строка должна быть расположена первой сверху. Пустое пространство выше и ниже строк должно иметь одинаковую высоту. Не должно быть пустого пространства между фоторамками.

Формат ввода:

```js
solution(1, 100, 30);
```

Формат вывода:

```js
[{ width: 100, height: 30, x: 50, y: 0 }];
```

2. Список товаров

Статус: Полное решение, 10/10 баллов

Нужно сверстать pixel perfect макет из фигмы.
Скриншот макета:
![alt text](https://i.postimg.cc/fLbxN3St/2.png)

3. Figma to HTML

Статус: Решение неверно, 0/20 баллов

Нужно написать функцию, которая преобразует JSON файл в HTML, а затем вернет HTML в виде строки.
Решение находится по пути /tester/example/solution.js

4. Лабиринт

Статус: Частичное решение, 26.25/30 баллов

Нужно написать и функцию для выхода из лабиринта, при этом гарантируется, что выход есть всегда. Функция принимает на вход начальную точку start и объект game для взаимодействия с лабиринтом и должна вернуть точку { x, y }, для которой game.state(x, y).finish === true
У game есть асинхронные функции, которые позволяют двигаться от любой ячейки влево, вправо, вверх или вниз. При попытке шагнуть в стену или из непосещённой клетки методы кидают ошибку. Также асинхронная функция получения состояния ячейки работает только для посещённых ячеек, для остальных – кидает ошибку.
Решение находится по пути /src/main.js

5. Объявление

Статус: Решение неверно, 0/30 баллов

Задача написать JavaScript-функцию, которая разместит блоки с текстом как газетные колонки.
Пример ожидаемого расположения элементов:
![alt text](https://i.postimg.cc/t48qyJSS/6.png)
Пример решения:
![alt text](https://i.postimg.cc/c4ZT9cdT/7.jpg)

6. Drag and Drop

Статус: Полное решение, 30/30 баллов

Есть две основные зоны: зона с тегами и зона с письмами. Теги можно перетаскивать из зоны всех тегов на письма и между письмами, а также снимать с писем, перетаскивая обратно в зону тегов.

Если начать перетаскивать тег то:

Тегу должен быть присвоен класс Tag_dragged — это позволит перетаскиваемому тегу иметь специальное отображение.
Зоне писем должен быть присвоен класс Letters_dropzone — это позволит подсветить возможное назначение для перетаскивания.
Если тег перетаскивается с письма, то дополнительно зоне тегов должен быть присвоен класс Tags_dropzone — это позволит подсветить ещё одно возможное назначение для перетаскивания.
Если тег перетаскивается с письма, то дополнительно зоне тегов должен быть присвоен класс Tags_dropzone — это позволит подсветить ещё одно возможное назначение для перетаскивания. При перетаскивании тега на письмо, на котором данный тег отсутствует, письму присваивается класс Letter_dragovered — это позволяет подсвечивать только те письма, на которые можно бросить данный тег.

При перетаскивании тега с письма на зону тегов, зоне тегов должен быть присвоен класс Tags_dragovered — это позволит подсветить возможность бросить тег.

При броске тега на письмо, на котором данный тег отсутствует, он должен быть на него проставлен. При этом новый тег должен оказаться после всех существующих. Если тег перетаскивался с другого письма, то он должен исчезнуть с исходного.

При перетаскивании тега с письма на зону тегов, он должен сниматься с письма.

7. Многопоточные вычисления

Статус: Частичное решение, 18/30 баллов

Ваша команда занимается разработкой сервиса быстрого поиска книг по нескольким ключевым предложениям. Алгоритм такого поиска подразумевает вычисление хеша из входных данных по определённому алгоритму, описанному ниже.
Вам поставили задачу адаптировать получение хеша под многопоточные вычисления, причём нужно учитывать, что количество потоков ограничено и не известно. Члены команды уже написали подпрограмму Worker, которая умеет высчитывать хеш, однако она является однопоточной, и из-за особенностей реализации после вычисления хеша инстанс подпрограммы нужно удалить.

Алгоритм построения хеша:

1. Необходимо преобразовать результаты работы подпрограмм к одному хешу.
2. На вход вашей функции передаётся массив строк, где записаны данные.
3. Нужно с помощью подпрограмм (Worker) каждую строку преобразовать в хеш, а затем результаты попарно конкатенировать в порядке расположения в массиве.
4. Если количество элементов нечётное, последний конкатенируем со своей копией.
5. Над новыми строками повторяем предыдущий шаг, пока не останется один хеш (от последней строки, тоже следует вычислить хеш).
6. Если во входных данных есть пустой массив, то нужно вернуть «0» (строкой).

Логика работы:
![alt text](https://i.postimg.cc/ZKXYzjqt/example-1.png)

Формат ввода:

```js
[
  "easy to get started",
  "70 real-world techniques",
  "Go may be the perfect systems language.",
  "testing and debugging",
  "sophisticated cloud-native",
  "Principal Engineer",
  "open source contributors",
];
```

Формат вывода:

```js
"a29de6e1bb95780cf38d9124b26e7011ebf6809e091eb6c98abc1961e40ea8c6";
```

8. Применить стили

Статус: Частичное решение, 20/40 баллов

Дан набор CSS-правил и HTML-дерево, требуется применить CSS и выдать итоговый HTML.
Нужно написать и экспортировать функцию, которая установит в свойства styles HTML-элементов финальные значения и вернёт это дерево.

Скриншот работы:
![alt text](https://i.postimg.cc/zG32qT0n/asd.jpg)
